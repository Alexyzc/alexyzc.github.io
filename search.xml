<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Python常用模块处理]]></title>
      <url>%2F2017%2F03%2F07%2FPython%2F</url>
      <content type="text"><![CDATA[一、开篇 邮件模块 Excel处理模块 日志模块 PDF模块 MD5处理 mongodb索引和聚合 邮件模块： 此处邮件模块处理是程序运行中希望将程序运行的日志信息或者错误捕获信息发送给指定的收件人，通过邮件可以了解程序运行的状态或者出错信息。 发送邮件需求的模块 smtplib email 发送邮件需求的步骤 email 构造邮件 smtplib 协议发送邮件 邮件发送主要涉及SMTP协议, 接收主要涉及POP 协议、IMAP协议 邮件基本包含哪些基础的东西,以QQ邮箱为例: 收件人 发件人 邮件主题 邮件正文 邮件附件 实例代码一： 12345678910111213141516171819202122232425import emailfrom email.mime.text import MIMETextimport smtplibfrom email.header import Header# 构造邮件信息msg = MIMEText(&apos;这是python自动脚本邮件信息。&apos;, &apos;plain&apos;, &apos;utf-8&apos;) # 邮件正文# QQ发给公司： 多了这步 server.starttls()from_addr = &quot;xxx@foxmail.com&quot; # 发件人password = &quot;****&quot; # 发件人邮箱密码smtp_server = &quot;smtp.qq.com&quot; # SMTP 服务器地址port = 587 # SMTP 服务器端口to_addr = &quot;paul.xie@chinascope.com&quot; # 收件人msg[&quot;From&quot;] = Header(&quot;Python_Tester&lt;&#123;&#125;&gt;&quot;.format(from_addr)) # 显示的邮件发件人msg[&quot;To&quot;] = Header(&quot;admin&lt;&#123;&#125;&gt;&quot;.format(to_addr))msg[&quot;Subject&quot;] = Header(&quot;from Python_Tester Test&quot;, &quot;utf-8&quot;) # 邮件主题# 发送邮件 server = smtplib.SMTP(smtp_server, port)server.starttls()server.set_debuglevel(1)server.login(from_addr, password=password)server.sendmail(from_addr, [to_addr], msg=msg.as_string())server.quit() 实例代码二： 12345678910111213141516171819 # 使用yagmail 第三方模块 import yagmail # 设置发送人信息及SMTP服务器和端口 yag = yagmail.SMTP(user=&quot;xxx@foxmail.com&quot;,password=&quot;****&quot;,host=&quot;smtp.qq.com&quot;,port=&quot;587&quot; ) contents = u&quot;系统提醒,您有错误信息发生。&quot; yag.send(to=[&quot;xxx@outlook.com&quot;,&quot;xxx@qq.com&quot;], subject=&quot;yagmail&quot;, contents=contents) # 参数说明 &apos;&apos;&apos; to : 收件人，可以接受一个list 发送至多人 subject: 邮件主题 contents: 邮件正文，默认是文本信息，其实还可以接收各种常见的文件比如，*.jpg, *.docx, *.pdf ，*.html 等信息，只需要设置完整路径，或者同一目录下文件名称即可。 &apos;&apos;&apos; 日志模块：详见日志更友好的了解程序运行中的信息或者错误信息，方便了解程序运行状态以及报错信息如何使用logging模块？需要了解的内容： 日志的级别 关于日志的基本概念：记录器，处理器，过滤器，格式化器 编写常规的日志需要的步骤 日志的级别：日志分等级，设置好等级，比设置好的级别大的才能在显示 DEBUG INFO WARN ERROR CRITICAL默认日志名为root, 默认日志级别为WARN 在程序中配置日志存在三种方法： 使用INI文件配置 使用字典或者JSON配置 在程序源代码中配置 实例代码： &apos;&apos;&apos; import logging logger = logging.getLogger(&quot;logger_name&quot;) # 记录器 handler = logging.StreamHandler() # 日志显示在控制台，还可以设置将日志信息输出为文本形式FileHandler() formatter = logging.Formatter( &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;) handler.setFormatter(formatter) # 设置日志显示方式 logger.addHandler(handler) # 添加处理器 logger.setLevel(logging.DEBUG) # 设置日志级别 logger.debug(&apos;often makes a very good meal of %s&apos;, &apos;visiting tourists&apos;) # 日志在程序中的使用 &apos;&apos;&apos; 总结： &apos;&apos;&apos; # 基本步骤，如下： # 创建logger logger = logging.getLogger(&quot;Your_logger_name&quot;) logger.setLevel(logging.DEBUG) # 创建handler logger_one = logging.StreamHandler() logger_one.setLevel(logging.INFO) # 创建Formatter formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;) # 配置Logger logger_one.setFormatter(formatter) logger.addHandler(logger_one) # 使用logger logger.info(&apos;info message&apos;) &apos;&apos;&apos; Excel模块:Excel基本概念：一个workbook 可以包含多个sheet, 一个sheet中包含更多的行列组成的表格 Workbook : 工作簿 sheet: 工作表 cell: 单元格如何通过程序来实现？步骤如下： 实例化workbook 添加sheet 往单元格里面写入内容 保存文件 实例代码一： &apos;&apos;&apos; # xlwt的基本使用就是往单元格中进行内容的写入 import xlwt # 导入xlwt模块 wb = xlwt.Workbook() ws.write(0, 0, 1234.56) # 第一行第一列写入123.56 ws.write(2, 0, 1) # 第三行第一列写入 1 ws.write(2, 1, 1) # 第三行第二列写入 1 ws.write(2, 2, xlwt.Formula(&quot;A3+B3&quot;)) # 第三行第三列是前面值之和 wb.save(&apos;example.xls&apos;) # 保存为文件名example.xls &apos;&apos;&apos; 实例代码二： &apos;&apos;&apos; # 将mongodb数据库中的数据导入入excel中 &quot;&quot;&quot; 1.根据数据获取行和列数 2.先写入header信息 3.再两重循环写入内容值 &quot;&quot;&quot; from pymongo import MongoClient from xlwt import Workbook from xlwt import easyxf # 可以定义字体，颜色等样式 class MongoToXls(object): def __init__(self, collection, name): self.work_book = collection self.sheet_name = name self.wb = Workbook() self.ws = [self.wb.add_sheet(one) for one in self.sheet_name] self.style = easyxf(&quot;align: vert centre, horiz center&quot;) pass def info(self, number): self.contents = list(self.work_book[number].find()) self.headers = [key for key in self.contents[0].keys()] rows = len(self.contents) columns = len(self.headers) return rows, columns def write_header(self, number): ws = self.ws[number] _, columns = self.info(number) for i in range(0, columns): ws.write(0, i, self.headers[i], style=self.style) def write_content(self, number): ws = self.ws[number] rows, columns = self.info(number) if rows &gt;= 65536: rows = 65535 for j in range(1, rows + 1): for k in range(0, columns): ws.write(j, k, str(self.contents[j - 1][self.headers[k]]), style=self.style) def save(self): name = &quot;_&quot;.join(self.sheet_name) +&quot;2&quot;+ str(&quot;.xls&quot;) self.wb.save(str(name)) collection1 = MongoClient()[&quot;db5&quot;][&quot;base&quot;] collection2 = MongoClient()[&quot;db5&quot;][&quot;items&quot;] collection3 = MongoClient()[&quot;db5&quot;][&quot;values&quot;] collection = [collection1, collection2, collection3] name = [&quot;base&quot;, &quot;items&quot;, &quot;values&quot;] A = MongoToXls(collection=collection, name=name) for number in range(len(collection)): print A.info(number) A.write_header(number) A.write_content(number) A.save() &apos;&apos;&apos; PDF模块: pdfminer模块可以将pdf信息转换为字符串信息 实例代码： &apos;&apos;&apos; # 读取本地pdf转化为字符串 from cStringIO import StringIO from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.converter import TextConverter from pdfminer.layout import LAParams from pdfminer.pdfpage import PDFPage def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec=&apos;utf-8&apos;, laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, &apos;rb&apos;) as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() device.close() retstr.close() return text # 将数据读入内存在进行处理 url_data = requests.get(&quot;xxx.pdf&quot;).content data = StringIO(url_data) parser = PDFParser(data) document = PDFDocument(parser) rercmgr = PDFResourceManager(document) retstr = StringIO() laparams = LAParams() codec = &apos;utf-8&apos; device = TextConverter(rercmgr, retstr, codec=codec, laparams=laparams) interpreter = PDFPageInterpreter(rercmgr, device) for page in PDFPage.create_pages(document): interpreter.process_page(page) text = retstr.getvalue()# 返回的text 就能普通字符串的处理提取信息了。 &apos;&apos;&apos; MD5处理： 实例代码： &apos;&apos;&apos; from hashlib md = hashlib.md5() md.update(&quot;字符串&quot;) md5.hexdigest() // 现在的问题是想要根据一个字典数据形成一个hash, 以使得可以判断字典数据没有完全一致的。 str = (&quot;_&quot;.join(&quot;%s:%s&quot; % (key, value) for key, value in dict_item.items() if key not in (&quot;ct&quot;)) + &quot;_&quot; + str(number)).encode(&quot;utf-8&quot;) md5.update(str) md5.hexdigest() &apos;&apos;&apos; mongodb索引和聚合： 目的：能够很好的对数据进行判重处理 思路 根据入库的数据进行生成md5值，将md5值设置为唯一索引值，完成了较好的去重操作 步骤： 索引 ‘’’ coll_values.create_index([(“md5_values”, pymongo.ASCENDING)], unique=True) ‘’’ 聚合操作：对mongodb数据中数据进行一些统计工作 match group limit sort 实例代码： &apos;&apos;&apos; # 根据股票信息统计年份的数据数 query = [ { &quot;$match&quot;: {&quot;key&quot;: code, &quot;year&quot;: year, &quot;type&quot;: type} }, { &quot;$group&quot;: {&quot;_id&quot;: {&quot;code&quot;: &quot;$key&quot;, &quot;year&quot;:&quot;$year&quot;}, &quot;total&quot;: {&quot;$sum&quot;:1}} } ] total = [] for code in [&quot;ACH&quot;, &quot;IKGH&quot;, &quot;ALN&quot;, &quot;AMCN&quot;, &quot;ATAI&quot;, &quot;AXN&quot;, &quot;ATV&quot;, &quot;BIDU&quot;, &quot;BITA&quot;, &quot;BORN&quot;, &quot;BSPM&quot;]: for one in [&quot;2011&quot;, &apos;2012&apos;, &apos;2013&apos;, &apos;2014&apos;, &quot;2015&quot;]: A = Count(code=code, year=one, type=&quot;Annual&quot;, factor=&quot;Income Statement&quot;) result = A.aggregation() total.append(list(result)) print(total) &apos;&apos;&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity生命周期简述]]></title>
      <url>%2F2017%2F03%2F07%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[一、开篇Android生命周期中，Acitivity保持长时间不变的状态,过渡状态(暂时状态)包括：onCreate()，onStart()操作后很快调用onResume()方法 RESUME_ACTIVITY(运行状态)：Activity处于前台，且用户可以与其交互 PAUSE_ACTIVITY(暂停状态): Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码 STOP_ACTIVITY(停止状态): Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码 从上面的Activity生命周期图片可以看出来，其启动后执行的顺序： 1onCreate –&gt; onStart –&gt; onResume –&gt; onPause –&gt; onStop –&gt; onDestroy 但是很多时候，Activity还有很多方法：onContentChanged， onPostCreate， onPostResume， onConfigurationChanged， onSaveInstanceState， onRestoreInstanceState 二、Activity生命周期 进程之间的通信对应App来说，其Activity的生命周期执行是与系统进程中的ActivityManager有一定关系，如： system_server进程（系统进程），framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（ATP），ActivityManagerService（AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。 App进程（应用程序所在进程），主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(AT)和ActivityManagerProxy（AMP），除了下图中所示的线程，其实还有很多线程，比如signal catcher线程等。 Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事件，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息. 结合上图Activity生命周期，比如暂停Activity流程如下： 线程1的AMS中调用线程2的ATP来发送事件；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题） 线程2通过binder将暂停Activity的事件传输到App进程的线程4； 线程4通过handler消息机制，将暂停Activity的消息发送给主线程； 主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息(PAUSE_ACTIVITY)时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的层层调用，最后便会调用到Activity.onPause()方法。 上述由AMS完成了onPause()控制，那么同理Activity的其他生命周期也是这么个流程来进行控制的。 特定场景分析下Activity的生命周期 首次启动 1onCreate –&gt; onStart –&gt; onResume 按下返回键 1onPause –&gt; onStop –&gt; onDestroy 按Home键 1onPause –&gt; onSaveInstanceState –&gt; onStop 再次打开 1onRestart –&gt; onStart –&gt; onResume 屏幕旋转不做任何配置 1234//启动Activity会执行如下方法：onCreate –&gt; onStart –&gt; onResume//之后旋转屏幕，则Activity会被销毁并重新创建，之后便会执行如下方法onPause –&gt; onSaveInstanceState –&gt; onStop –&gt; onDestroy –&gt; onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 在AndroidManifest配置文件里声明android:configChanges属性 123456789//默认屏幕旋转会重新创建，当然可以通过在配置文件里加上如下代码:android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;（sdk&gt;13时需加上screenSize）//这个时候再旋转屏幕便不会销毁Activity，这时候再旋转屏幕可以看到只会执行onConfigurationChanged方法，有什么在屏幕旋转的逻辑可以重写这个方法：public void onConfigurationChanged(Configuration newConfig) &#123; if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; // TODO: &#125; super.onConfigurationChanged(newConfig);&#125; FirstActivity打开SecondActivity FirstActivity打开SecondActivity，这时候FirstActivity生命周期的方法是这样的： onPause –&gt; onSaveInstanceState –&gt; onStop, 这个时候在SecondActivity按返回键，FirstActivity会有以下集中情况： 正常情况下会执行： onRestart -&gt; onStart -&gt; onResume 当系统由于要回收内存而把 activity 销毁时 Activity在onPause或者onStop状态下都有可能遇到由于突发事件系统需要回收内存，之后的onDestroy方法便不会再执行，这时候会执行： onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 实例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public class ActivityDemo extends Activity&#123;private static final String TAG = &quot;ActivityDemo&quot;;private EditText mEditText;private String mString;//定义一个String类型用来存取我们的EditText输入值////当Activity第一次被创建时调用,我们可以在这进行初始化操作public void onCreate(Bundle saveInstanceState)&#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); mEditText = (EditText)findViewById(R.id.editText); Log.e(TAG,&quot;start onCreate...&quot;);&#125;//onStart()方法在Activity开始被执行时调用，它紧随onCreate()方法之后调用@Overrideprotected void onStart()&#123; super.onStart(); Log.e(TAG,&quot;start onStart...&quot;);&#125;//当按HOME键，在启动应用程勋，要恢复当前的状态//当Activity从stopped状态启动时会调用onRestart(),后面总是调用onStart()方法@Overrideprotected void onRestart()&#123; super.onRestart(); mEditText.setText(mString); Log.e(TAG,&quot;start onRestart...&quot;);&#125;//onResume()方法在Activity即将与用户交互时调用@Overrideprotected void onResume()&#123; super.onResume(); Log.e(TAG,&quot;start onResume...&quot;);&#125;//按HOME键，在onPause，将输入的值赋给mString//在一个Activity启动另一个Activity时调用，它通常被用来持久化数据、停止动画或其他耗费资源的动作，//下一个Activity必须等待这个方法返回后在启动，所以在这里做过多的操作@Overrideprotected void onPause()&#123; super.onPause(); mString = mEditText.getText().toString(); Log.e(TAG,&quot;start onPause...&quot;);&#125;//onStop()方法在一个新的Activity启动、其他的Activity切换到前台、当天Activity被销毁时都会被调用@Overrideprotected void onStop()&#123; super.onStop(); Log.e(TAG,&quot;start onStop...&quot;);&#125;//Activitybe被销毁时调用@Overrideprotected void onDestroy()&#123; super.onDestroy(); Log.e(TAG,&quot;start onDestroy...&quot;);&#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之封装思想]]></title>
      <url>%2F2017%2F03%2F06%2FJava%E4%B9%8B%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统架构简述]]></title>
      <url>%2F2017%2F02%2F24%2FAndroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[一、开篇Android系统其底层基于Linux操作系统为基础，上层采用Java和Native层。它们是通过系统调用Syscall连通系统的内核空间和用户空间。 二、Android架构系统启动流程 Andorid系统启动过程：Loader—&gt;Kernel—&gt;Native—&gt;Native—&gt;Framework—&gt;App Loader层？ Boot Rom:当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 Kernel层? 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。 Native层 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Native层主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖 Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含 加载ZygoteInit类，注册Zygote Socket服务端套接字； 加载虚拟机； preloadClasses； preloadResouces; System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service，等服务。 App层？ Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上 所有的App进程都是由Zygote进程fork生成的 Syscall &amp;&amp; JNI? Native与Kernel之间有一层系统调用(SysCall)层 Java层与Native(C/C++)层之间的纽带JNI]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
