<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SpringMVC简介]]></title>
      <url>%2F2017%2F03%2F20%2FSpringMVC%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[Web MVC简介web开发中的请求-响应模型web开发时的请求/响应模型 Web项目中从客户端到服务器数据传输的具体的步骤如下： Web浏览器(如：firfox)发起请求，如访问https://www.baidu.com/ Web服务器（如：Tomcat）接收请求，处理请求（比如新增用户，则将用户保存一下），最后产生响应（一般为html或json等） Web服务器处理完成后，返回内容给Web客户端，客户端对接收的内容进行处理（如：浏览器客户端对接收到的响应内容进行渲染以及展示） 由上述的模型可知，Web开发中Web客户端发起请求，Web服务器接收、处理并产生响应。一般Web服务器是不能主动通知Web客户端更新内容，不排除服务器的自动推送或HTML5 websocket客户端实现Web服务器主动通知Web客户端等 标准的MVC模型概述MVC模型，是一种架构型的模式，本身不引入新功能，只是帮助我们将开发中的结构组织的更加合理，使暂时与模型分离、流程控制逻辑、业务逻辑调用与展示逻辑分离 什么是MVC（Model-View-Controller）三元组？ Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组间（包含数据和行为）。它可分离成：Value Object（数据）和服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。 View（视图）：负责进行模型的展示，一般情况下就是我们所见的用户界面，客户端想看到的内容 Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。其实，控制器做了个调度员的工作。 从web开发开发的请求/响应模型图看到，在标准的mvc中模型能主动推数据给视图进行更新（观察者设计模式，在模型上注册视图，当模型更新时自动更新视图），但在Web开发中模型是无法主动推给视图（无法主动更新用户界面），，因为在Web开发是请求-响应模型。 Web MVC概述模型-视图-控制器概念和标准的MVC一样，请参考上图，接下来先看下Web MVC标准架构图，如图： 在Web MVC模式下，模型无法主动推送数据给视图，如果用户想要视图更新，需要再发送一次请求（既请求-响应模型）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux基础命令总结]]></title>
      <url>%2F2017%2F03%2F14%2FLinux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[开篇 在日常测试、开发过程中，常用到Linux命令，熟练的掌握和使用这些命令可以提高工作效率，对问题的定位也起到事半功倍的效果。 内容Linux路径篇12345678910111213141516/ # 表示根目录，是绝对路径./ # 表示当前目录，是相对路径../ # 表示上一级目录，是相对路径/root # root用户的主目录/home/用户名 # 普通用户的主目录/bin # 存放Linux常用的命令/boot # 存放系统启动时要用到的文件/dev # 存放Linux系统中使用外部设备/etc # 存放系统管理时用到的配置文件和子目录/sbin # 存放管理员的系统管理程序/lib # 存放系统动态链接共享库/lost+found # 系统运行异常时产生的错误，会将遗失的片断放在这里/mnt # 可临时讲别的外部设备挂接在此目录下/proc # 存在系统内存中的信息/usr # 用户的应用程序和文件都存放在这个目录下/tmp # 存放临时的文件目录 以上目录中，又存在若干个子目录和文件，Linux中的目录就是Windows中的文件夹 Linux命令篇（基础命令） vi编辑器： 功能：生成新文件或编辑查看文件 格式：vi file_name（文件名称） 说明：上面的命令直接进入vi的命令模式从命令模式进入的编辑模式需要在当前键盘上按“i”或“a”键，使用ESC键可以从编辑的模式进入命令模式。 编辑模式可执行的操作：插入各种文本信息 编辑模式向命令模式转换，可以按下面的一种键： “i”：插入文本 “a”: 追加文本 命令模式可以执行的操作 “:w”: 保存文本 “:wq”: 保存并退出 “:wq!”: 保存并强制退出 “:q”: 退出 “:q!”: 强制退出 “dd”: 删除一行文字(当前删除行，点击键盘dd) “x”：删除一个字符 “:n”: 光标移至文本第n行 “$”: 光标移到文本的行尾 “G”: 光标移到文本的末尾 “ZZ”: 存盘退出 “/字符串”: 查找某个字符串 命令模式向编辑模式转换，可以按ESC键12#生成文件名为helloworld的文件，文件存在于当前根目录下[root@localhost ~]# vi helloworld 系统开关及重启 123456789#退出[root@localhost ~]# logout[root@localhost ~]# exit或键盘Ctrl+D //使用命令#重启[root@localhost ~]# reboot[root@localhost ~]# shutdown -r &lt;time&gt; //使用命令，例如：shutdown -r now（立刻重启），shutdown -r 11:30（11：30进行重启）#关机root@localhost ~]# haltroot@localhost ~]# shutdown -h &lt;time&gt; //使用命令，例如：shutdown -h now 现在立刻关闭系统，shutdown -h 11:30(11:30自动关闭系统) pwd用法 功能描述：查看用户当前所处的绝对路径12[root@localhost ~]# pwd/root ls用法 功能描述：显示指定目录下的内容 格式 ：ls [参数] [目录或文件]1234567891011121314151617181920212223242526272829303132#显示当前目录内容,如下所示[root@localhost /]# ls bin boot dev etc home lib lib64 lost+found media mnt opt proc root sbin selinux srv sys tmp usr var#显示指定目录/home/test下的内容[root@localhost /]# ls /home/alexyzc/ Desktop Documents Downloads Music Pictures Public Templates Videos#显示当前目录详细内容[root@localhost /]# ls -ltotal 98dr-xr-xr-x. 2 root root 4096 Mar 14 04:10 bindr-xr-xr-x. 5 root root 1024 Mar 13 10:34 bootdrwxr-xr-x. 18 root root 3740 Mar 15 10:37 devdrwxr-xr-x. 102 root root 12288 Mar 15 10:37 etcdrwxr-xr-x. 3 root root 4096 Mar 13 10:35 homedr-xr-xr-x. 10 root root 4096 Mar 13 10:30 libdr-xr-xr-x. 9 root root 12288 Mar 14 04:09 lib64drwx------. 2 root root 16384 Mar 13 10:26 lost+founddrwxr-xr-x. 2 root root 4096 Sep 23 2011 mediadrwxr-xr-x. 3 root root 4096 Mar 13 10:36 mntdrwxr-xr-x. 3 root root 4096 Mar 13 10:37 optdr-xr-xr-x. 151 root root 0 Mar 15 10:36 procdr-xr-x---. 2 root root 4096 Mar 15 10:37 rootdr-xr-xr-x. 2 root root 12288 Mar 14 04:10 sbindrwxr-xr-x. 7 root root 0 Mar 15 10:36 selinuxdrwxr-xr-x. 2 root root 4096 Sep 23 2011 srvdrwxr-xr-x. 13 root root 0 Mar 15 10:36 sysdrwxrwxrwt. 17 root root 4096 Mar 15 10:37 tmpdrwxr-xr-x. 13 root root 4096 Mar 13 10:27 usrdrwxr-xr-x. 21 root root 4096 Mar 13 10:32 var#显示当前目录下的所有文件，包括隐藏文件[root@localhost /]# ls -a. .. .autofsck bin boot dev etc home lib lib64 lost+found media mnt opt proc root sbin selinux srv sys tmp usr var cd用法 功能描述：改变当前目录 格式 ：cd 目录12345678910111213141516#回退到当前目录的上一级目录，并且借助pwd查看当前处于啥目录[root@localhost ~]# cd ..[root@localhost /]# pwd/#回到当前用户的主目录，并且借助pwd查看是否回到主目录[root@localhost ~]# cd [root@localhost ~]# pwd/root#用绝对路径切换到alexyzc目录下[root@localhost alexyzc]# cd /home/alexyzc/[root@localhost alexyzc]# pwd/home/alexyzc#使用相对路径切换到当前目录的上一级的上一级目录下[root@localhost ~]# cd ../../ [root@localhost ~]# pwd/ mkdir&amp;rmdir用法 功能：创建目录 格式：mkdir[参数][目录名1][目录名2]123456#创建一个目录名为test[root@localhost ~]# mkdir test# 删除多个空目录[root@localhost ~]# rmdir bb cc dd #rmdir只能删除空文件夹，删除非空文件夹就会报错“rmdir: failed to remove `bb/&apos;: Directory not empty”# 删除非空文件夹命令[root@localhost ~]# rm -rf 文件名称 cp用法 功能：拷贝文件或目录 格式：cp[参数][源文件或目录][目标文件或目录]cp命令总结1234567#将当前文件testfile拷贝到绝对路径/home/alexyzc/下。并且命名为myfile[root@localhost Desktop]# lstestfile[root@localhost Desktop]# cp ./testfile /home/alexyzc/myfile[root@localhost Desktop]# ls /home/alexyzc/Desktop Downloads Music Pictures Templates VideosDocuments hello myfile Public testfile Mv用法 功能：可以对文件或目录进行移动 格式：mv[参数][源对象][目的对象]12345678910111213#将文件testfile移动到新的目录下并改名为newfile[root@localhost Desktop]# pwd/home/alexyzc/Desktop[root@localhost Desktop]# mv ./testfile ./bb/newfile[root@localhost Desktop]# lsbb[root@localhost Desktop]# cd bb/[root@localhost bb]# lsnewfile# 将文件夹bb移动到新的目录下并更名为caca[root@localhost alexyzc]# mv ./Desktop/bb/ ./Downloads/caca [root@localhost alexyzc]# ls ./Downloads/caca rm用法 功能：删除文件或删除非空目录 格式：rm [参数]文件或目录12345678910111213141516171819202122232425262728#当前目录下复制myfile文件重命名为11.txt/22.txt/33.tex[root@localhost alexyzc]# cp myfile 11.txt[root@localhost alexyzc]# ls11.txt Documents hello myfile Public testfileDesktop Downloads Music Pictures Templates Videos[root@localhost alexyzc]# cp myfile 22.txt[root@localhost alexyzc]# cp myfile 33.txt[root@localhost alexyzc]# ls11.txt 33.txt Documents hello myfile Public testfile22.txt Desktop Downloads Music Pictures Templates Videos#删除当前文件下myfile文件[root@localhost alexyzc]# rm myfile#删除当前目录下hello目录，有提示[root@localhost alexyzc]# rm -r hello/rm: remove directory `hello&apos;? y# 删除当前目录下hello目录，不提示[root@localhost alexyzc]# rm -rf ./hello/[root@localhost alexyzc]# ls11.txt 33.txt Documents Music Public testfile22.txt Desktop Downloads Pictures Templates Videos# 删除当前目录下多个文件[root@localhost alexyzc]# rm -r 11.txt 22.txt 33.txtrm: remove regular file `11.txt&apos;? yrm: remove regular file `22.txt&apos;? yrm: remove regular file `33.txt&apos;? y[root@localhost alexyzc]# lsDesktop Downloads Pictures Templates VideosDocuments Music Public testfile chmod用法 功能：修改文件权限 格式：chmod [参数] 权限 文件或目录chmod详解12345678[root@localhost ~]# chmod 611 hello #使用数字表示法修改文件myfile的权限[root@localhost ~]# ls -l hello #使用ls命令查看权限修改结果[root@localhost ~]# chmod u=rwx hello #使用文字表示法修改文件myfile的权限[root@localhost ~]# ls -l hello[root@localhost ~]# chmod g+r hello[root@localhost ~]# ls -l hello[root@localhost ~]# chmod o=r hello[root@localhost ~]# ls -l hello chown用法 功能：修改文件的属主（该例中的组wuxh需要替换为你系统中存在的组） 格式：chown [参数] 用户名 文件1234[root@localhost ~]# ls -l hello #先查看hello的属主信息[root@localhost ~]# chown wuxh hello #把文件hello的属主修改为用户wuxh[root@localhost ~]# ls -l hello #看看属主信息是否修改[root@localhost ~]# chown wuxh dir2 #把目录dir2的属主修改为用户wuxh chgrp用法 功能：修改文件的所属组 格式：chgrp [选项] 组名 文件1234[root@localhost ~]# ls -l hello #执行之前先查看属主信息[root@localhost ~]#chgrp wuxh hello #把文件myfile的组修改为组wuxh[root@localhost ~]# ls -l hello #执行之后再查看属主信息[root@localhost ~]# chgrp wuxh dir2 #把目录mydir的组修改为组wuxh find用法 功能：从指定的目录下开始查找某个文件 格式：find 起始目录 寻找条件 文件名12[root@localhost ~]# cd /home/test[root@localhost ~]# find ./ -name 111.txt #在当前目录及子目录中查找文件名为111.txt的文件 grep用法 功能：从某个文件中查询指定的字符串 格式：grep [选项] [查找模式] [ 文件名1，文件名2…]1234[root@localhost ~]# grep‘bind’ hello #从文件hello中查找字符串bind[root@localhost ~]# grep ‘[a-zA-Z0-9]ind’ hello 按照正则表达式，查找以字符或者数字开头连接ind的行÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷ echo用法 功能：在显示屏上回显文字或者用来查看环境变量的值123[root@localhost ~]# echo“hello，boy”[root@localhost ~]# echo $PATH÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷÷ su用法 功能：切换用户 注意su 与su - 的区别12345678910#使用普通用户登陆linux，执行ifconfig，这个命令在/sbin目录下[alexyzc@localhost Desktop]$ ipconfigbash: ipconfig: command not found #系统提示command not found#查看path的取值，是否有/sbin目录[alexyzc@localhost Desktop]$ echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/alexyzc/bin#用户切换为root[alexyzc@localhost Desktop]$ su rootPassword: [root@localhost Desktop]# ifconfig clear用法 功能：清屏1[root@localhost ~]# clear man用法 功能：联机帮助12[root@localhost ~]# man ps #查看ps命令的使用[root@localhost ~]# man date #查看date命令的使用 help用法 功能：在线命令查看帮助123456789101112131415[root@localhost ~]# help cd #查看cd命令的使用[root@localhost ~]# help pwd #查看pwd命令的使用pwd: pwd [-LP] Print the name of the current working directory. Options: -L print the value of $PWD if it names the current working directory -P print the physical directory, without any symbolic links By default, `pwd&apos; behaves as if `-L&apos; were specified. Exit Status: Returns 0 unless an invalid option is given or the current directory cannot be read. whereis用法 功能：查看命令的存放文职12[root@localhost ~]# whereis cd[root@localhost ~]# whereis pwd id 用法 功能：查看当前用户的uid、gid、groups12[root@localhost ~]# iduid=0(root) gid=0(root) groups=0(root) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 useradd与userdel 功能：添加用户123456[root@localhost ~]# useradd wang #添加用户wang[root@localhost ~]# useradd zhang #添加用户wang[root@localhost ~]# ls /home/ #查看/home目录下有什么信息[root@localhost ~]# userdel wang #删除用户wang ，但不删除目录/home/wang[root@localhost ~]# userdel –r zhang #删除用户wang，并删除目录/home/wang[root@localhost ~]# ls /home/ #查看以上操作有什么区别？ passwd用法 功能：修改用户口令，注意，如果当前用户是root，该命令修改的将是root的口令123[root@localhost ~]# useradd wang #添加用户wang[root@localhost ~]# passwd wang #修改用户wang的口令[root@localhost ~]# passwd # 注意：这样修改的是当前用户的口令 groupadd 用法 功能：添加组12345678910[root@localhost ~]# groupadd manager #添加组 manager[root@localhost ~]# groupdel manager #删除组 manager[root@localhost ~]# groupadd manager #添加组 manager [root@localhost ~]# gpasswd manager #设置组manager的密码[root@localhost ~]# gpasswd -r manager # 取消组manager的密码 [root@localhost ~]# gpasswd -A wang manager #设置用户wang为manager组的管理员[root@localhost ~]# gpasswd -a zhang manager #添加用户zhang到组mananger[root@localhost ~]# gpasswd -d zhang manager #从组manager中删除用户zhang[root@localhost ~]# groups #查看组的信息[root@localhost ~]# newgrp #切换组 ps用法 显示进程12[root@localhost ~]# ps -ef #显示当前系统中运行的进程[root@localhost ~]# ps -ef|grep pid #查询某个进程 top命令 动态显示进程信息[root@localhost ~]# top kill命令 功能：将指定的进程杀死 格式：kill -s 信号名称 pid / kill -n 36 pid1[root@localhost ~]# kill -9 pid #常用例子ps -ef |grep java ，kill -9 pid tar命令 功能：将文件或目录进行打包 格式：tar[参数] 打包后的文件名 文件或目录12[root@localhost ~]# tar cvf test.tar /home/test #把home下test目录打成tar包[root@localhost ~]# tar xvf test.tar #把test.tar 解包 gzip命令 12[root@localhost ~]# gzip test.tar #把test.tar文件进行压缩[root@localhost ~]# gzip –d test.tar.gz #把test.tar.gz压缩包解压缩 rpm命令 1234[root@localhost ~]# rpm -ivh jdk-6u1-linux-i586.rpm #安装该包[root@localhost ~]# rpm -e jdk-6u1-linux-i586 #卸载该包注意：没有.rpm[root@localhost ~]# rpm -qi jdk-6u1-linux-i586 #查看包信息,注意：没有.rpm[root@localhost ~]# rpm -ql jdk-6u1-linux-i586 #列出包内容,注意：没有.rpm ifconfig命令 123456789101112[root@localhost ~]# ifconfig #功能：查看或者设置网络配置 [root@localhost ~]# ifconfig eth0 192.168.0.200 #功能：配置eth0的ip地址[root@localhost ~]# ifconfig eth0 down #功能：禁用eth0网卡[root@localhost ~]# ifconfig eth0 up #功能：启用eth0网卡*************************************************************************[root@localhost ~]# hostname #功能：查看主机名称[root@localhost ~]# ping #功能：查看网络上主机是否功能[root@localhost ~]# netstat #功能：显示网络连接，路由表或者网络接口信息netstat -n #显示所有已经建立的有效连接netstat -a #显示所有有效连接，包括监听的一些连接netstat -s #按照各协议显示统计数据 route命令 功能：添加路由和查看路由信息1[root@localhost ~]#route add -net192.168.11.0 netmask 255.255.255.0 eth0 netconfig命令 功能:实现网络的配置12[root@localhost ~]#netconfig[root@localhost ~]#service network restart]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[App测试中Android与iOS区别]]></title>
      <url>%2F2017%2F03%2F14%2FApp%E6%B5%8B%E8%AF%95%E4%B8%ADAndroid%E4%B8%8EiOS%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[开篇 在app测试过程中，基于不同的移动终端，其具有不同的属性，在测试过程中存在相同点，也存在不同的测试点，下面简单介绍下Android于iOS的区别。 内容App测试中Android与iOS区别 Android长按home键呼出应用列表和切换应用，然后右滑则终止应用； 多分辨率测试，Android端20多种，ios较少； 手机操作系统，Android较多，ios较少且不能降级，只能单向升级；新的ios系统中的资源库不能完全兼容低版本中的ios系统中的应用，低版本ios系统中的应用调用了新的资源库，会直接导致闪退（Crash）； 操作习惯：Android，Back键是否被重写，测试点击Back键后的反馈是否正确；应用数据从内存移动到SD卡后能否正常运行等； push测试：Android：点击home键，程序后台运行时，此时接收到push，点击后唤醒应用，此时是否可以正确跳转;ios，点击home键关闭程序和屏幕锁屏的情况（红点的显示）； 安装卸载测试：Android的下载和安装的平台和工具和渠道比较多，ios主要有app store，iTunes和testflight下载； 升级测试：可以被升级的必要条件：新旧版本具有相同的签名；新旧版本具有相同的包名；有一个标示符区分新旧版本（如版本号），对于Android若有内置的应用需检查升级之后内置文件是否匹配（如内置的输入法）,注意点： 并发（中断）测试：闹铃弹出框提示，另一个应用的启动、视频音频的播放，来电、用户正在输入等，语音、录音等的播放时强制其他正在播放的要暂停； 数据来源的测试：输入，选择、复制、语音输入，安装不同输入法输入等； push（推送）测试：在开关机、待机状态下执行推送，消息先死及其推送跳转的正确性；应用在开发、未打开状态、应用启动且在后台运行的情况下是push显示和跳转否正确；推送消息阅读前后数字的变化是否正确；多条推送的合集的显示和跳转是否正确； 分享跳转：分享后的文案是否正确；分享后跳转是否正确，显示的消息来源是否正确； 触屏测试：同时触摸不同的位置或者同时进行不同操作，查看客户端的处理情况，是否会crash等 原地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[案件生成]]></title>
      <url>%2F2017%2F03%2F08%2F%E7%94%9F%E6%88%90%E6%A1%88%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[一、开篇 需求 随机生成案件 内容包括：身份证、手机号、微信号、QQ号、家庭住址、电子邮箱、性别等 生成Json格式的案件 可以生成jar包，随机生成N条案件，当前路径：java -jar jar包名称 N 示例核心代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 package com.cn.jetty.im; import java.util.ArrayList; import java.util.Map; import com.cn.jetty.bean.in.CaseApplyListBean; import com.cn.jetty.bean.in.CaseBean; import com.cn.jetty.util.DateUtil; import com.cn.jetty.util.FileUtil; import com.cn.jetty.util.GeneratorData; import com.cn.jetty.util.JsonUtil; import com.cn.jetty.util.RandomValue; import com.cn.jetty.util.dao.GeneratorDao; public class OutCaseList &#123;public static void main(String[] args) &#123; FileUtil f = new FileUtil(); GeneratorDao gd = new GeneratorDao(); int out = Integer.parseInt(args[0]); ArrayList&lt;CaseBean&gt; arrcase = new ArrayList&lt;CaseBean&gt;(); for (int i = 0; i &lt; out ;i++) &#123; Map amt = GeneratorData.generatoramt(); CaseBean casebean = new CaseBean(); casebean.setLoanNo(GeneratorData.generatorCaseNo()); casebean.setName(RandomValue.getChineseName()); casebean.setId(GeneratorData.generatorId()); casebean.setIdAddr(RandomValue.getRoad()); if (RandomValue.getNum(0, 20) &gt; 10) &#123; casebean.setGender(&quot;男&quot;); &#125;else if(RandomValue.getNum(0, 20) &lt; 10) &#123; casebean.setGender(&quot;女&quot;); &#125;else &#123; casebean.setGender(&quot;其它&quot;); &#125; casebean.setCaseAmt((String) amt.get(&quot;caseAmt&quot;)); casebean.setDebtAmt(amt.get(&quot;debtAmt&quot;).toString()); casebean.setOverdueAmt(amt.get(&quot;overdueAmt&quot;).toString()); casebean.setPenaltyInterest(amt.get(&quot;penaltyInterest&quot;).toString()); casebean.setApplyDate(amt.get(&quot;applyDate&quot;).toString()); casebean.setOverdueDate(amt.get(&quot;overdueDate&quot;).toString()); casebean.setLendingInstitution(&quot;xxxx&quot;); casebean.setQqList(GeneratorData.generatorQqList()); casebean.setWechatList(GeneratorData.generatorQqList()); casebean.setPhoneList(GeneratorData.generatorPhoneBean()); casebean.setAddrList(GeneratorData.generatorAddressBean()); casebean.setSpecialCase(0); casebean.setProductCode(&quot;APP2&quot;); casebean.setAheadSettleAmt(amt.get(&quot;aheadSettleAmt&quot;).toString()); casebean.setEmail(RandomValue.getEmail(6, 9)); // System.out.println(JsonUtil.toJsonString(casebean)); // 插入t_case表中 gd.add(casebean); arrcase.add(casebean); &#125; CaseApplyListBean caselist = new CaseApplyListBean(); caselist.setCaseApplyBaseEntitys(arrcase); System.out.println(JsonUtil.toJsonString(caselist)); String json = JsonUtil.toJsonString(caselist); String filename = &quot;MMD&quot; + DateUtil.currTime() + &quot;.case&quot;; System.out.println(filename); f.WriteFile(json,&quot;MMD_CASE&quot;, &quot;/&quot;+filename,&quot;UTF-8&quot;); &#125; &#125; 结果展示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&#123; &quot;caseApplyBaseEntitys&quot;: [ &#123; &quot;addrList&quot;: [ &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;奉化街142号-6-6&quot;, &quot;relation&quot;: &quot;4&quot; &#125;, &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;巢湖街113号-1-10&quot;, &quot;relation&quot;: &quot;4&quot; &#125;, &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;礼阳路40号-2-9&quot;, &quot;relation&quot;: &quot;1&quot; &#125;, &#123; &quot;addrType&quot;: &quot;1&quot;, &quot;address&quot;: &quot;峄县路64号-13-7&quot;, &quot;relation&quot;: &quot;2&quot; &#125;, &#123; &quot;addrType&quot;: &quot;1&quot;, &quot;address&quot;: &quot;云霄大厦28号-20-4&quot;, &quot;relation&quot;: &quot;2&quot; &#125; ], &quot;aheadSettleAmt&quot;: &quot;2000.00&quot;, &quot;applyDate&quot;: &quot;2016-06-15&quot;, &quot;caseAmt&quot;: &quot;20000.00&quot;, &quot;debtAmt&quot;: &quot;18000.00&quot;, &quot;email&quot;: &quot;3aw6i9t4@sohu.com&quot;, &quot;gender&quot;: &quot;男&quot;, &quot;id&quot;: &quot;230705198906216705&quot;, &quot;idAddr&quot;: &quot;台西五路139号-14-1&quot;, &quot;lendingInstitution&quot;: &quot;MMJF&quot;, &quot;loanNo&quot;: &quot;CASE_1488985377852&quot;, &quot;name&quot;: &quot;桑伊媛&quot;, &quot;overdueAmt&quot;: &quot;2000.00&quot;, &quot;overdueDate&quot;: &quot;2017-03-10&quot;, &quot;penaltyInterest&quot;: &quot;0.00&quot;, &quot;phoneList&quot;: [ &#123; &quot;name&quot;: &quot;宫珠&quot;, &quot;phoneNo&quot;: &quot;13406483407&quot;, &quot;relation&quot;: &quot;0&quot; &#125;, &#123; &quot;name&quot;: &quot;颜祥言&quot;, &quot;phoneNo&quot;: &quot;15303150205&quot;, &quot;relation&quot;: &quot;0&quot; &#125; ], &quot;productCode&quot;: &quot;APP2&quot;, &quot;qqList&quot;: [ ], &quot;specialCase&quot;: 0, &quot;wechatList&quot;: [ &quot;985377881491&quot;, &quot;985377881873&quot; ] &#125;, &#123; &quot;addrList&quot;: [ &#123; &quot;addrType&quot;: &quot;1&quot;, &quot;address&quot;: &quot;临邑路55号-12-7&quot;, &quot;relation&quot;: &quot;2&quot; &#125;, &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;夏津大厦54号-20-9&quot;, &quot;relation&quot;: &quot;0&quot; &#125;, &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;济宁支街43号-2-9&quot;, &quot;relation&quot;: &quot;3&quot; &#125;, &#123; &quot;addrType&quot;: &quot;0&quot;, &quot;address&quot;: &quot;莆田街35号-4-4&quot;, &quot;relation&quot;: &quot;4&quot; &#125;, &#123; &quot;addrType&quot;: &quot;1&quot;, &quot;address&quot;: &quot;泰州街117号-5-9&quot;, &quot;relation&quot;: &quot;3&quot; &#125; ], &quot;aheadSettleAmt&quot;: &quot;2000.00&quot;, &quot;applyDate&quot;: &quot;2016-06-15&quot;, &quot;caseAmt&quot;: &quot;20000.00&quot;, &quot;debtAmt&quot;: &quot;18000.00&quot;, &quot;email&quot;: &quot;gua7k50za@163.net&quot;, &quot;gender&quot;: &quot;男&quot;, &quot;id&quot;: &quot;610204198102283790&quot;, &quot;idAddr&quot;: &quot;扬州街21号-5-3&quot;, &quot;lendingInstitution&quot;: &quot;MMJF&quot;, &quot;loanNo&quot;: &quot;CASE_1488985378565&quot;, &quot;name&quot;: &quot;訾舒&quot;, &quot;overdueAmt&quot;: &quot;2000.00&quot;, &quot;overdueDate&quot;: &quot;2017-03-10&quot;, &quot;penaltyInterest&quot;: &quot;0.00&quot;, &quot;phoneList&quot;: [ &#123; &quot;name&quot;: &quot;孙美桂&quot;, &quot;phoneNo&quot;: &quot;15105237705&quot;, &quot;relation&quot;: &quot;0&quot; &#125;, &#123; &quot;name&quot;: &quot;寿龙胜&quot;, &quot;phoneNo&quot;: &quot;15201428987&quot;, &quot;relation&quot;: &quot;4&quot; &#125;, &#123; &quot;name&quot;: &quot;姜春&quot;, &quot;phoneNo&quot;: &quot;13506340655&quot;, &quot;relation&quot;: &quot;2&quot; &#125; ], &quot;productCode&quot;: &quot;APP2&quot;, &quot;qqList&quot;: [ &quot;985378567136&quot;, &quot;98537856711&quot;, &quot;985378567501&quot;, &quot;985378567515&quot; ], &quot;specialCase&quot;: 0, &quot;wechatList&quot;: [ &quot;985378567497&quot; ] &#125; ]&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MockServer]]></title>
      <url>%2F2017%2F03%2F08%2F%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[一、开篇 概念 如何配置 ${} jetty]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python常用模块处理]]></title>
      <url>%2F2017%2F03%2F07%2FPython%2F</url>
      <content type="text"><![CDATA[一、开篇 邮件模块 Excel处理模块 日志模块 PDF模块 MD5处理 mongodb索引和聚合 邮件模块： 此处邮件模块处理是程序运行中希望将程序运行的日志信息或者错误捕获信息发送给指定的收件人，通过邮件可以了解程序运行的状态或者出错信息。 发送邮件需求的模块 smtplib email 发送邮件需求的步骤 email 构造邮件 smtplib 协议发送邮件 邮件发送主要涉及SMTP协议, 接收主要涉及POP 协议、IMAP协议 邮件基本包含哪些基础的东西,以QQ邮箱为例: 收件人 发件人 邮件主题 邮件正文 邮件附件 实例代码一： 12345678910111213141516171819202122232425import emailfrom email.mime.text import MIMETextimport smtplibfrom email.header import Header# 构造邮件信息msg = MIMEText(&apos;这是python自动脚本邮件信息。&apos;, &apos;plain&apos;, &apos;utf-8&apos;) # 邮件正文# QQ发给公司： 多了这步 server.starttls()from_addr = &quot;xxx@foxmail.com&quot; # 发件人password = &quot;****&quot; # 发件人邮箱密码smtp_server = &quot;smtp.qq.com&quot; # SMTP 服务器地址port = 587 # SMTP 服务器端口to_addr = &quot;paul.xie@chinascope.com&quot; # 收件人msg[&quot;From&quot;] = Header(&quot;Python_Tester&lt;&#123;&#125;&gt;&quot;.format(from_addr)) # 显示的邮件发件人msg[&quot;To&quot;] = Header(&quot;admin&lt;&#123;&#125;&gt;&quot;.format(to_addr))msg[&quot;Subject&quot;] = Header(&quot;from Python_Tester Test&quot;, &quot;utf-8&quot;) # 邮件主题# 发送邮件 server = smtplib.SMTP(smtp_server, port)server.starttls()server.set_debuglevel(1)server.login(from_addr, password=password)server.sendmail(from_addr, [to_addr], msg=msg.as_string())server.quit() 实例代码二： 12345678910111213141516171819 # 使用yagmail 第三方模块 import yagmail # 设置发送人信息及SMTP服务器和端口 yag = yagmail.SMTP(user=&quot;xxx@foxmail.com&quot;,password=&quot;****&quot;,host=&quot;smtp.qq.com&quot;,port=&quot;587&quot; ) contents = u&quot;系统提醒,您有错误信息发生。&quot; yag.send(to=[&quot;xxx@outlook.com&quot;,&quot;xxx@qq.com&quot;], subject=&quot;yagmail&quot;, contents=contents) # 参数说明 &apos;&apos;&apos; to : 收件人，可以接受一个list 发送至多人 subject: 邮件主题 contents: 邮件正文，默认是文本信息，其实还可以接收各种常见的文件比如，*.jpg, *.docx, *.pdf ，*.html 等信息，只需要设置完整路径，或者同一目录下文件名称即可。 &apos;&apos;&apos; 日志模块：详见Python指南Logging日志更友好的了解程序运行中的信息或者错误信息，方便了解程序运行状态以及报错信息如何使用logging模块？需要了解的内容： 日志的级别 关于日志的基本概念：记录器，处理器，过滤器，格式化器 编写常规的日志需要的步骤 日志的级别：日志分等级，设置好等级，比设置好的级别大的才能在显示 DEBUG INFO WARN ERROR CRITICAL默认日志名为root, 默认日志级别为WARN 在程序中配置日志存在三种方法： 使用INI文件配置 使用字典或者JSON配置 在程序源代码中配置 实例代码： &apos;&apos;&apos; import logging logger = logging.getLogger(&quot;logger_name&quot;) # 记录器 handler = logging.StreamHandler() # 日志显示在控制台，还可以设置将日志信息输出为文本形式FileHandler() formatter = logging.Formatter( &apos;%(asctime)s %(name)-12s %(levelname)-8s %(message)s&apos;) handler.setFormatter(formatter) # 设置日志显示方式 logger.addHandler(handler) # 添加处理器 logger.setLevel(logging.DEBUG) # 设置日志级别 logger.debug(&apos;often makes a very good meal of %s&apos;, &apos;visiting tourists&apos;) # 日志在程序中的使用 &apos;&apos;&apos; 总结： &apos;&apos;&apos; # 基本步骤，如下： # 创建logger logger = logging.getLogger(&quot;Your_logger_name&quot;) logger.setLevel(logging.DEBUG) # 创建handler logger_one = logging.StreamHandler() logger_one.setLevel(logging.INFO) # 创建Formatter formatter = logging.Formatter(&apos;%(asctime)s - %(name)s - %(levelname)s - %(message)s&apos;) # 配置Logger logger_one.setFormatter(formatter) logger.addHandler(logger_one) # 使用logger logger.info(&apos;info message&apos;) &apos;&apos;&apos; Excel模块:Excel基本概念：一个workbook 可以包含多个sheet, 一个sheet中包含更多的行列组成的表格 Workbook : 工作簿 sheet: 工作表 cell: 单元格如何通过程序来实现？步骤如下： 实例化workbook 添加sheet 往单元格里面写入内容 保存文件 实例代码一： &apos;&apos;&apos; # xlwt的基本使用就是往单元格中进行内容的写入 import xlwt # 导入xlwt模块 wb = xlwt.Workbook() ws.write(0, 0, 1234.56) # 第一行第一列写入123.56 ws.write(2, 0, 1) # 第三行第一列写入 1 ws.write(2, 1, 1) # 第三行第二列写入 1 ws.write(2, 2, xlwt.Formula(&quot;A3+B3&quot;)) # 第三行第三列是前面值之和 wb.save(&apos;example.xls&apos;) # 保存为文件名example.xls &apos;&apos;&apos; 实例代码二： &apos;&apos;&apos; # 将mongodb数据库中的数据导入入excel中 &quot;&quot;&quot; 1.根据数据获取行和列数 2.先写入header信息 3.再两重循环写入内容值 &quot;&quot;&quot; from pymongo import MongoClient from xlwt import Workbook from xlwt import easyxf # 可以定义字体，颜色等样式 class MongoToXls(object): def __init__(self, collection, name): self.work_book = collection self.sheet_name = name self.wb = Workbook() self.ws = [self.wb.add_sheet(one) for one in self.sheet_name] self.style = easyxf(&quot;align: vert centre, horiz center&quot;) pass def info(self, number): self.contents = list(self.work_book[number].find()) self.headers = [key for key in self.contents[0].keys()] rows = len(self.contents) columns = len(self.headers) return rows, columns def write_header(self, number): ws = self.ws[number] _, columns = self.info(number) for i in range(0, columns): ws.write(0, i, self.headers[i], style=self.style) def write_content(self, number): ws = self.ws[number] rows, columns = self.info(number) if rows &gt;= 65536: rows = 65535 for j in range(1, rows + 1): for k in range(0, columns): ws.write(j, k, str(self.contents[j - 1][self.headers[k]]), style=self.style) def save(self): name = &quot;_&quot;.join(self.sheet_name) +&quot;2&quot;+ str(&quot;.xls&quot;) self.wb.save(str(name)) collection1 = MongoClient()[&quot;db5&quot;][&quot;base&quot;] collection2 = MongoClient()[&quot;db5&quot;][&quot;items&quot;] collection3 = MongoClient()[&quot;db5&quot;][&quot;values&quot;] collection = [collection1, collection2, collection3] name = [&quot;base&quot;, &quot;items&quot;, &quot;values&quot;] A = MongoToXls(collection=collection, name=name) for number in range(len(collection)): print A.info(number) A.write_header(number) A.write_content(number) A.save() &apos;&apos;&apos; PDF模块: pdfminer模块可以将pdf信息转换为字符串信息 实例代码： &apos;&apos;&apos; # 读取本地pdf转化为字符串 from cStringIO import StringIO from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter from pdfminer.converter import TextConverter from pdfminer.layout import LAParams from pdfminer.pdfpage import PDFPage def convert_pdf_2_text(path): rsrcmgr = PDFResourceManager() retstr = StringIO() device = TextConverter(rsrcmgr, retstr, codec=&apos;utf-8&apos;, laparams=LAParams()) interpreter = PDFPageInterpreter(rsrcmgr, device) with open(path, &apos;rb&apos;) as fp: for page in PDFPage.get_pages(fp, set()): interpreter.process_page(page) text = retstr.getvalue() device.close() device.close() retstr.close() return text # 将数据读入内存在进行处理 url_data = requests.get(&quot;xxx.pdf&quot;).content data = StringIO(url_data) parser = PDFParser(data) document = PDFDocument(parser) rercmgr = PDFResourceManager(document) retstr = StringIO() laparams = LAParams() codec = &apos;utf-8&apos; device = TextConverter(rercmgr, retstr, codec=codec, laparams=laparams) interpreter = PDFPageInterpreter(rercmgr, device) for page in PDFPage.create_pages(document): interpreter.process_page(page) text = retstr.getvalue()# 返回的text 就能普通字符串的处理提取信息了。 &apos;&apos;&apos; MD5处理： 实例代码： &apos;&apos;&apos; from hashlib md = hashlib.md5() md.update(&quot;字符串&quot;) md5.hexdigest() // 现在的问题是想要根据一个字典数据形成一个hash, 以使得可以判断字典数据没有完全一致的。 str = (&quot;_&quot;.join(&quot;%s:%s&quot; % (key, value) for key, value in dict_item.items() if key not in (&quot;ct&quot;)) + &quot;_&quot; + str(number)).encode(&quot;utf-8&quot;) md5.update(str) md5.hexdigest() &apos;&apos;&apos; mongodb索引和聚合： 目的：能够很好的对数据进行判重处理 思路 根据入库的数据进行生成md5值，将md5值设置为唯一索引值，完成了较好的去重操作 步骤： 索引 ‘’’ coll_values.create_index([(“md5_values”, pymongo.ASCENDING)], unique=True) ‘’’ 聚合操作：对mongodb数据中数据进行一些统计工作 match group limit sort 实例代码： &apos;&apos;&apos; # 根据股票信息统计年份的数据数 query = [ { &quot;$match&quot;: {&quot;key&quot;: code, &quot;year&quot;: year, &quot;type&quot;: type} }, { &quot;$group&quot;: {&quot;_id&quot;: {&quot;code&quot;: &quot;$key&quot;, &quot;year&quot;:&quot;$year&quot;}, &quot;total&quot;: {&quot;$sum&quot;:1}} } ] total = [] for code in [&quot;ACH&quot;, &quot;IKGH&quot;, &quot;ALN&quot;, &quot;AMCN&quot;, &quot;ATAI&quot;, &quot;AXN&quot;, &quot;ATV&quot;, &quot;BIDU&quot;, &quot;BITA&quot;, &quot;BORN&quot;, &quot;BSPM&quot;]: for one in [&quot;2011&quot;, &apos;2012&apos;, &apos;2013&apos;, &apos;2014&apos;, &quot;2015&quot;]: A = Count(code=code, year=one, type=&quot;Annual&quot;, factor=&quot;Income Statement&quot;) result = A.aggregation() total.append(list(result)) print(total) &apos;&apos;&apos;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Activity生命周期简述]]></title>
      <url>%2F2017%2F03%2F07%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[一、开篇Android生命周期中，Acitivity保持长时间不变的状态,过渡状态(暂时状态)包括：onCreate()，onStart()操作后很快调用onResume()方法 RESUME_ACTIVITY(运行状态)：Activity处于前台，且用户可以与其交互 PAUSE_ACTIVITY(暂停状态): Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码 STOP_ACTIVITY(停止状态): Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码 从上面的Activity生命周期图片可以看出来，其启动后执行的顺序： 1onCreate –&gt; onStart –&gt; onResume –&gt; onPause –&gt; onStop –&gt; onDestroy 但是很多时候，Activity还有很多方法：onContentChanged， onPostCreate， onPostResume， onConfigurationChanged， onSaveInstanceState， onRestoreInstanceState 二、Activity生命周期 进程之间的通信对应App来说，其Activity的生命周期执行是与系统进程中的ActivityManager有一定关系，如： system_server进程（系统进程），framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（ATP），ActivityManagerService（AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。 App进程（应用程序所在进程），主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(AT)和ActivityManagerProxy（AMP），除了下图中所示的线程，其实还有很多线程，比如signal catcher线程等。 Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事件，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息. 结合上图Activity生命周期，比如暂停Activity流程如下： 线程1的AMS中调用线程2的ATP来发送事件；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题） 线程2通过binder将暂停Activity的事件传输到App进程的线程4； 线程4通过handler消息机制，将暂停Activity的消息发送给主线程； 主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息(PAUSE_ACTIVITY)时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的层层调用，最后便会调用到Activity.onPause()方法。 上述由AMS完成了onPause()控制，那么同理Activity的其他生命周期也是这么个流程来进行控制的。 特定场景分析下Activity的生命周期 首次启动 1onCreate –&gt; onStart –&gt; onResume 按下返回键 1onPause –&gt; onStop –&gt; onDestroy 按Home键 1onPause –&gt; onSaveInstanceState –&gt; onStop 再次打开 1onRestart –&gt; onStart –&gt; onResume 屏幕旋转不做任何配置 1234//启动Activity会执行如下方法：onCreate –&gt; onStart –&gt; onResume//之后旋转屏幕，则Activity会被销毁并重新创建，之后便会执行如下方法onPause –&gt; onSaveInstanceState –&gt; onStop –&gt; onDestroy –&gt; onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 在AndroidManifest配置文件里声明android:configChanges属性 123456789//默认屏幕旋转会重新创建，当然可以通过在配置文件里加上如下代码:android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;（sdk&gt;13时需加上screenSize）//这个时候再旋转屏幕便不会销毁Activity，这时候再旋转屏幕可以看到只会执行onConfigurationChanged方法，有什么在屏幕旋转的逻辑可以重写这个方法：public void onConfigurationChanged(Configuration newConfig) &#123; if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; // TODO: &#125; super.onConfigurationChanged(newConfig);&#125; FirstActivity打开SecondActivity FirstActivity打开SecondActivity，这时候FirstActivity生命周期的方法是这样的： onPause –&gt; onSaveInstanceState –&gt; onStop, 这个时候在SecondActivity按返回键，FirstActivity会有以下集中情况： 正常情况下会执行： onRestart -&gt; onStart -&gt; onResume 当系统由于要回收内存而把 activity 销毁时 Activity在onPause或者onStop状态下都有可能遇到由于突发事件系统需要回收内存，之后的onDestroy方法便不会再执行，这时候会执行： onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 实例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public class ActivityDemo extends Activity&#123;private static final String TAG = &quot;ActivityDemo&quot;;private EditText mEditText;private String mString;//定义一个String类型用来存取我们的EditText输入值////当Activity第一次被创建时调用,我们可以在这进行初始化操作public void onCreate(Bundle saveInstanceState)&#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); mEditText = (EditText)findViewById(R.id.editText); Log.e(TAG,&quot;start onCreate...&quot;);&#125;//onStart()方法在Activity开始被执行时调用，它紧随onCreate()方法之后调用@Overrideprotected void onStart()&#123; super.onStart(); Log.e(TAG,&quot;start onStart...&quot;);&#125;//当按HOME键，在启动应用程勋，要恢复当前的状态//当Activity从stopped状态启动时会调用onRestart(),后面总是调用onStart()方法@Overrideprotected void onRestart()&#123; super.onRestart(); mEditText.setText(mString); Log.e(TAG,&quot;start onRestart...&quot;);&#125;//onResume()方法在Activity即将与用户交互时调用@Overrideprotected void onResume()&#123; super.onResume(); Log.e(TAG,&quot;start onResume...&quot;);&#125;//按HOME键，在onPause，将输入的值赋给mString//在一个Activity启动另一个Activity时调用，它通常被用来持久化数据、停止动画或其他耗费资源的动作，//下一个Activity必须等待这个方法返回后在启动，所以在这里做过多的操作@Overrideprotected void onPause()&#123; super.onPause(); mString = mEditText.getText().toString(); Log.e(TAG,&quot;start onPause...&quot;);&#125;//onStop()方法在一个新的Activity启动、其他的Activity切换到前台、当天Activity被销毁时都会被调用@Overrideprotected void onStop()&#123; super.onStop(); Log.e(TAG,&quot;start onStop...&quot;);&#125;//Activitybe被销毁时调用@Overrideprotected void onDestroy()&#123; super.onDestroy(); Log.e(TAG,&quot;start onDestroy...&quot;);&#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之封装思想]]></title>
      <url>%2F2017%2F03%2F06%2FJava%E4%B9%8B%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统架构简述]]></title>
      <url>%2F2017%2F02%2F24%2FAndroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[一、开篇Android系统其底层基于Linux操作系统为基础，上层采用Java和Native层。它们是通过系统调用Syscall连通系统的内核空间和用户空间。 二、Android架构系统启动流程 Andorid系统启动过程：Loader—&gt;Kernel—&gt;Native—&gt;Native—&gt;Framework—&gt;App Loader层？ Boot Rom:当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 Kernel层? 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。 Native层 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Native层主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖 Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含 加载ZygoteInit类，注册Zygote Socket服务端套接字； 加载虚拟机； preloadClasses； preloadResouces; System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service，等服务。 App层？ Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上 所有的App进程都是由Zygote进程fork生成的 Syscall &amp;&amp; JNI? Native与Kernel之间有一层系统调用(SysCall)层 Java层与Native(C/C++)层之间的纽带JNI]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
