<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Activity生命周期简述]]></title>
      <url>%2F2017%2F03%2F07%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%80%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[一、开篇Android生命周期中，Acitivity保持长时间不变的状态,过渡状态(暂时状态)包括：onCreate()，onStart()操作后很快调用onResume()方法 RESUME_ACTIVITY(运行状态)：Activity处于前台，且用户可以与其交互 PAUSE_ACTIVITY(暂停状态): Activity被在前台中处于半透明状态或者未覆盖全屏的其他Activity部分遮挡。 暂停的Activity不会接收用户输入，也无法执行任何代码 STOP_ACTIVITY(停止状态): Activity被完全隐藏，且对用户不可见；被视为后台Activity。 停止的Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码 从上面的Activity生命周期图片可以看出来，其启动后执行的顺序： 1onCreate –&gt; onStart –&gt; onResume –&gt; onPause –&gt; onStop –&gt; onDestroy 但是很多时候，Activity还有很多方法：onContentChanged， onPostCreate， onPostResume， onConfigurationChanged， onSaveInstanceState， onRestoreInstanceState 二、Activity生命周期 进程之间的通信对应App来说，其Activity的生命周期执行是与系统进程中的ActivityManager有一定关系，如： system_server进程（系统进程），framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（ATP），ActivityManagerService（AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的。 App进程（应用程序所在进程），主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(AT)和ActivityManagerProxy（AMP），除了下图中所示的线程，其实还有很多线程，比如signal catcher线程等。 Binder用于不同进程之间通信，由一个进程的Binder客户端向另一个进程的服务端发送事件，比如图中线程2向线程4发送事务；而handler用于同一个进程中不同线程的通信，比如图中线程4向主线程发送消息. 结合上图Activity生命周期，比如暂停Activity流程如下： 线程1的AMS中调用线程2的ATP来发送事件；（由于同一个进程的线程间资源共享，可以相互直接调用，但需要注意多线程并发问题） 线程2通过binder将暂停Activity的事件传输到App进程的线程4； 线程4通过handler消息机制，将暂停Activity的消息发送给主线程； 主线程在looper.loop()中循环遍历消息，当收到暂停Activity的消息(PAUSE_ACTIVITY)时，便将消息分发给ActivityThread.H.handleMessage()方法，再经过方法的层层调用，最后便会调用到Activity.onPause()方法。 上述由AMS完成了onPause()控制，那么同理Activity的其他生命周期也是这么个流程来进行控制的。 特定场景分析下Activity的生命周期 首次启动 1onCreate –&gt; onStart –&gt; onResume 按下返回键 1onPause –&gt; onStop –&gt; onDestroy 按Home键 1onPause –&gt; onSaveInstanceState –&gt; onStop 再次打开 1onRestart –&gt; onStart –&gt; onResume 屏幕旋转不做任何配置 1234//启动Activity会执行如下方法：onCreate –&gt; onStart –&gt; onResume//之后旋转屏幕，则Activity会被销毁并重新创建，之后便会执行如下方法onPause –&gt; onSaveInstanceState –&gt; onStop –&gt; onDestroy –&gt; onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 在AndroidManifest配置文件里声明android:configChanges属性 123456789//默认屏幕旋转会重新创建，当然可以通过在配置文件里加上如下代码:android:configChanges=&quot;keyboardHidden|orientation|screenSize&quot;（sdk&gt;13时需加上screenSize）//这个时候再旋转屏幕便不会销毁Activity，这时候再旋转屏幕可以看到只会执行onConfigurationChanged方法，有什么在屏幕旋转的逻辑可以重写这个方法：public void onConfigurationChanged(Configuration newConfig) &#123; if (newConfig.orientation == ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) &#123; // TODO: &#125; super.onConfigurationChanged(newConfig);&#125; FirstActivity打开SecondActivity FirstActivity打开SecondActivity，这时候FirstActivity生命周期的方法是这样的： onPause –&gt; onSaveInstanceState –&gt; onStop, 这个时候在SecondActivity按返回键，FirstActivity会有以下集中情况： 正常情况下会执行： onRestart -&gt; onStart -&gt; onResume 当系统由于要回收内存而把 activity 销毁时 Activity在onPause或者onStop状态下都有可能遇到由于突发事件系统需要回收内存，之后的onDestroy方法便不会再执行，这时候会执行： onCreate –&gt; onStart –&gt; onRestoreInstanceState –&gt; onResume 实例代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 public class ActivityDemo extends Activity&#123;private static final String TAG = &quot;ActivityDemo&quot;;private EditText mEditText;private String mString;//定义一个String类型用来存取我们的EditText输入值////当Activity第一次被创建时调用,我们可以在这进行初始化操作public void onCreate(Bundle saveInstanceState)&#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); mEditText = (EditText)findViewById(R.id.editText); Log.e(TAG,&quot;start onCreate...&quot;);&#125;//onStart()方法在Activity开始被执行时调用，它紧随onCreate()方法之后调用@Overrideprotected void onStart()&#123; super.onStart(); Log.e(TAG,&quot;start onStart...&quot;);&#125;//当按HOME键，在启动应用程勋，要恢复当前的状态//当Activity从stopped状态启动时会调用onRestart(),后面总是调用onStart()方法@Overrideprotected void onRestart()&#123; super.onRestart(); mEditText.setText(mString); Log.e(TAG,&quot;start onRestart...&quot;);&#125;//onResume()方法在Activity即将与用户交互时调用@Overrideprotected void onResume()&#123; super.onResume(); Log.e(TAG,&quot;start onResume...&quot;);&#125;//按HOME键，在onPause，将输入的值赋给mString//在一个Activity启动另一个Activity时调用，它通常被用来持久化数据、停止动画或其他耗费资源的动作，//下一个Activity必须等待这个方法返回后在启动，所以在这里做过多的操作@Overrideprotected void onPause()&#123; super.onPause(); mString = mEditText.getText().toString(); Log.e(TAG,&quot;start onPause...&quot;);&#125;//onStop()方法在一个新的Activity启动、其他的Activity切换到前台、当天Activity被销毁时都会被调用@Overrideprotected void onStop()&#123; super.onStop(); Log.e(TAG,&quot;start onStop...&quot;);&#125;//Activitybe被销毁时调用@Overrideprotected void onDestroy()&#123; super.onDestroy(); Log.e(TAG,&quot;start onDestroy...&quot;);&#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java之封装思想]]></title>
      <url>%2F2017%2F03%2F06%2FJava%E4%B9%8B%E5%B0%81%E8%A3%85%E6%80%9D%E6%83%B3%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android系统架构简述]]></title>
      <url>%2F2017%2F02%2F24%2FAndroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[一、开篇Android系统其底层基于Linux操作系统为基础，上层采用Java和Native层。它们是通过系统调用Syscall连通系统的内核空间和用户空间。 二、Android架构系统启动流程 Andorid系统启动过程：Loader—&gt;Kernel—&gt;Native—&gt;Native—&gt;Framework—&gt;App Loader层？ Boot Rom:当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 Kernel层? 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。 Native层 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 Native层主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖 Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含 加载ZygoteInit类，注册Zygote Socket服务端套接字； 加载虚拟机； preloadClasses； preloadResouces; System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service，等服务。 App层？ Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上 所有的App进程都是由Zygote进程fork生成的 Syscall &amp;&amp; JNI? Native与Kernel之间有一层系统调用(SysCall)层 Java层与Native(C/C++)层之间的纽带JNI]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F02%2F22%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
